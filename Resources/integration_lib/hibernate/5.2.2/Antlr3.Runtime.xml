<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Antlr3.Runtime</name>
    </assembly>
    <members>
        <member name="T:Antlr.Runtime.ANTLRFileStream">
            <summary>
            This is a char buffer stream that is loaded from a file
            all at once when you construct the object.  This looks very
            much like an ANTLReader or ANTLRInputStream, but it's a special case
            since we know the exact size of the object to load.  We can avoid lots
            of data copying. 
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ANTLRInputStream">
            <summary>
            A kind of ReaderStream that pulls from an InputStream.
            Useful for reading from stdin and specifying file encodings etc...
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ANTLRReaderStream">
            <summary>
              Vacuum all input from a Reader and then treat it like a StringStream.
              Manage the buffer manually to avoid unnecessary data copying.
              </summary>
            
              <remarks>
              If you need encoding, use ANTLRInputStream.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.ANTLRStringStream">
            <summary>
            A pretty quick CharStream that pulls all data from an array
            directly.  Every method call counts in the lexer.  Java's
            strings aren't very good so I'm avoiding.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.data">
            <summary>The data being scanned</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.n">
            <summary>How many characters are actually in the buffer</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.p">
            <summary>0..n-1 index into string of next char</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.line">
            <summary>line number 1..n within the input</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.charPositionInLine">
            <summary>The index of the character relative to the beginning of the line 0..n-1</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.markDepth">
            <summary>tracks how deep mark() calls are nested</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.markers">
            <summary>
            A list of CharStreamState objects that tracks the stream state
            values line, charPositionInLine, and p that can change as you
            move through the input stream.  Indexed from 1..markDepth.
            A null is kept @ index 0.  Create upon first call to mark().
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.name">
            <summary>What is name or source of this char stream?</summary> 
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.#ctor(System.String)">
            <summary>Copy data in string to a local char array</summary> 
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.#ctor(System.Char[],System.Int32)">
            <summary>This is the preferred constructor as no data is copied</summary> 
        </member>
        <member name="P:Antlr.Runtime.ANTLRStringStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.  The index is the index of char to
            be returned from LA(1).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.Reset">
            <summary>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.Seek(System.Int32)">
            <summary>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.BaseRecognizer">
            <summary>
            A generic recognizer that can handle recognizers generated from
            lexer, parser, and tree grammars.  This is all the parsing
            support code essentially; most of it is error recovery stuff and
            backtracking.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.BaseRecognizer.state">
            <summary>
            State of a lexer, parser, or tree parser are collected into a state
            object so the state can be shared.  This sharing is needed to
            have one grammar import others and share same error variables
            and other state variables.  It's a kind of explicit multiple
            inheritance via delegation of methods and shared state.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Reset">
            <summary>reset the parser's state; subclasses must rewinds the input stream</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Match(Antlr.Runtime.IIntStream,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
              Match current input symbol against ttype.  Attempt
              single token insertion or deletion error recovery.  If
              that fails, throw MismatchedTokenException.
              </summary>
            
              <remarks>
              To turn off single token insertion or deletion error
              recovery, override recoverFromMismatchedToken() and have it
              throw an exception. See TreeParser.recoverFromMismatchedToken().
              This way any error in a rule will cause an exception and
              immediate exit from rule.  Rule would recover by resynchronizing
              to the set of symbols that can follow rule ref.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.MatchAny(Antlr.Runtime.IIntStream)">
            <summary>Match the wildcard: in a symbol</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ReportError(Antlr.Runtime.RecognitionException)">
            <summary>Report a recognition problem.</summary>
            
              <remarks>
              This method sets errorRecovery to indicate the parser is recovering
              not parsing.  Once in recovery mode, no errors are generated.
              To get out of recovery mode, the parser must successfully match
              a token (after a resync).  So it will go:
            
             		1. error occurs
             		2. enter recovery mode, report error
             		3. consume until token found in resynch set
             		4. try to resume parsing
             		5. next match() will reset errorRecovery mode
            
              If you override, make sure to update syntaxErrors if you care about that.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetErrorMessage(Antlr.Runtime.RecognitionException,System.String[])">
            <summary>What error message should be generated for the various exception types?</summary>
            
              <remarks>
              Not very object-oriented code, but I like having all error message
              generation within one method rather than spread among all of the
              exception classes. This also makes it much easier for the exception
              handling because the exception classes do not have to have pointers back
              to this object to access utility routines and so on. Also, changing
              the message for an exception type would be difficult because you
              would have to subclassing exception, but then somehow get ANTLR
              to make those kinds of exception objects instead of the default.
              This looks weird, but trust me--it makes the most sense in terms
              of flexibility.
            
              For grammar debugging, you will want to override this to add
              more information such as the stack frame with
              getRuleInvocationStack(e, this.getClass().getName()) and,
              for no viable alts, the decision description and state etc...
            
              Override this to change the message generated for one or more
              exception types.
              </remarks>
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.NumberOfSyntaxErrors">
            <summary>
              Get number of recognition errors (lexer, parser, tree parser).  Each
              recognizer tracks its own number.  So parser and lexer each have
              separate count.  Does not count the spurious errors found between
              an error and next valid token match
              </summary>
            
              <seealso cref="M:Antlr.Runtime.BaseRecognizer.ReportError(Antlr.Runtime.RecognitionException)"/>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetErrorHeader(Antlr.Runtime.RecognitionException)">
            <summary>What is the error header, normally line/character position information?</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetTokenErrorDisplay(Antlr.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.ToString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.EmitErrorMessage(System.String)">
            <summary>Override this method to change where error messages go</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Recover(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException)">
            <summary>
            Recover from an error found on the input stream.  This is
            for NoViableAlt and mismatched symbol exceptions.  If you enable
            single token insertion and deletion, this will usually not
            handle mismatched symbol exceptions but there could be a mismatched
            token that the match() routine could not recover from.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.BeginResync">
            <summary>
            A hook to listen in on the token consumption during error recovery.
            The DebugParser subclasses this to fire events to the listenter.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ComputeContextSensitiveRuleFOLLOW">
            <summary>
              Compute the context-sensitive FOLLOW set for current rule.
              This is set of token types that can follow a specific rule
              reference given a specific call chain.  You get the set of
              viable tokens that can possibly come next (lookahead depth 1)
              given the current call chain.  Contrast this with the
              definition of plain FOLLOW for rule r:
              </summary>
            
               FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
            
              where x in T* and alpha, beta in V*; T is set of terminals and
              V is the set of terminals and nonterminals.  In other words,
              FOLLOW(r) is the set of all tokens that can possibly follow
              references to r in *any* sentential form (context).  At
              runtime, however, we know precisely which context applies as
              we have the call chain.  We may compute the exact (rather
              than covering superset) set of following tokens.
            
              For example, consider grammar:
            
              stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
                   | "return" expr '.'
                   ;
              expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
              atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
                   | '(' expr ')'
                   ;
            
              The FOLLOW sets are all inclusive whereas context-sensitive
              FOLLOW sets are precisely what could follow a rule reference.
              For input input "i=(3);", here is the derivation:
            
              stat => ID '=' expr ';'
                   => ID '=' atom ('+' atom)* ';'
                   => ID '=' '(' expr ')' ('+' atom)* ';'
                   => ID '=' '(' atom ')' ('+' atom)* ';'
                   => ID '=' '(' INT ')' ('+' atom)* ';'
                   => ID '=' '(' INT ')' ';'
            
              At the "3" token, you'd have a call chain of
            
                stat -> expr -> atom -> expr -> atom
            
              What can follow that specific nested ref to atom?  Exactly ')'
              as you can see by looking at the derivation of this specific
              input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
            
              You want the exact viable token set when recovering from a
              token mismatch.  Upon token mismatch, if LA(1) is member of
              the viable next token set, then you know there is most likely
              a missing token in the input stream.  "Insert" one by just not
              throwing an exception.
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.RecoverFromMismatchedToken(Antlr.Runtime.IIntStream,System.Int32,Antlr.Runtime.BitSet)">
            <summary>Attempt to recover from a single missing or extra token.</summary>
            
              EXTRA TOKEN
            
              LA(1) is not what we are looking for.  If LA(2) has the right token,
              however, then assume LA(1) is some extra spurious token.  Delete it
              and LA(2) as if we were doing a normal match(), which advances the
              input.
            
              MISSING TOKEN
            
              If current token is consistent with what could come after
              ttype then it is ok to "insert" the missing token, else throw
              exception For example, Input "i=(3;" is clearly missing the
              ')'.  When the parser returns from the nested call to expr, it
              will have call chain:
            
                stat -> expr -> atom
            
              and it will be trying to match the ')' at this point in the
              derivation:
            
                   => ID '=' '(' INT ')' ('+' atom)* ';'
                                      ^
              match() will see that ';' doesn't match ')' and report a
              mismatched token error.  To recover, it sees that LA(1)==';'
              is in the set of tokens that can follow the ')' token
              reference in rule atom.  It can assume that you forgot the ')'.
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.RecoverFromMismatchedSet(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException,Antlr.Runtime.BitSet)">
            Not currently used 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetCurrentInputSymbol(Antlr.Runtime.IIntStream)">
            <summary>
              Match needs to return the current input symbol, which gets put
              into the label for the associated token ref; e.g., x=ID.  Token
              and tree parsers need to return different objects. Rather than test
              for input stream type or change the IntStream interface, I use
              a simple method to ask the recognizer to tell me what the current
              input symbol is.
              </summary>
            
              <remarks>This is ignored for lexers.</remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetMissingSymbol(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException,System.Int32,Antlr.Runtime.BitSet)">
            <summary>Conjure up a missing token during error recovery.</summary>
            
              <remarks>
              The recognizer attempts to recover from single missing
              symbols. But, actions might refer to that missing symbol.
              For example, x=ID {f($x);}. The action clearly assumes
              that there has been an identifier matched previously and that
              $x points at that token. If that token is missing, but
              the next token in the stream is what we want we assume that
              this token is missing and we keep going. Because we
              have to return some token to replace the missing token,
              we have to conjure one up. This method gives the user control
              over the tokens returned for missing tokens. Mostly,
              you will want to create something special for identifier
              tokens. For literals such as '{' and ',', the default
              action in the parser or tree parser works. It simply creates
              a CommonToken of the appropriate type. The text will be the token.
              If you change what tokens must be created by the lexer,
              override this method to create the appropriate tokens.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ConsumeUntil(Antlr.Runtime.IIntStream,Antlr.Runtime.BitSet)">
            <summary>Consume tokens until one matches the given token set</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.PushFollow(Antlr.Runtime.BitSet)">
            <summary>Push a rule's follow set using our own hardcoded stack</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleInvocationStack">
            <summary>
              Return <see cref="T:System.Collections.Generic.IList`1"/> of the rules in your parser instance
              leading up to a call to this method.  You could override if
              you want more details such as the file/line info of where
              in the parser java code a rule is invoked.
              </summary>
            
              <remarks>
              This is very useful for error messages and for context-sensitive
              error recovery.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleInvocationStack(System.Diagnostics.StackTrace)">
            <summary>
            A more general version of GetRuleInvocationStack where you can
            pass in the StackTrace of, for example, a RecognitionException
            to get it's rule stack trace.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.Failed">
            <summary>Return whether or not a backtracking attempt failed.</summary> 
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.TokenNames">
            <summary>
            Used to print out token names like ID during debugging and
            error reporting.  The generated parsers implement a method
            that overrides this to point to their String[] tokenNames.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.GrammarFileName">
            <summary>
            For debugging and other purposes, might want the grammar name.
            Have ANTLR generate an implementation for this method.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ToStrings(System.Collections.Generic.ICollection{Antlr.Runtime.IToken})">
            <summary>
            A convenience method for use most often with template rewrites.
            Convert a list of <see cref="T:Antlr.Runtime.IToken"/> to a list of <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleMemoization(System.Int32,System.Int32)">
            <summary>
              Given a rule number and a start token index number, return
              MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
              start index.  If this rule has parsed input starting from the
              start index before, then return where the rule stopped parsing.
              It returns the index of the last token matched by the rule.
              </summary>
            
              <remarks>
              For now we use a hashtable and just the slow Object-based one.
              Later, we can make a special one for ints and also one that
              tosses out data after we commit past input position i.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.AlreadyParsedRule(Antlr.Runtime.IIntStream,System.Int32)">
            <summary>
              Has this rule already parsed input at the current index in the
              input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
              If we attempted but failed to parse properly before, return
              MEMO_RULE_FAILED.
              </summary>
            
              <remarks>
              This method has a side-effect: if we have seen this input for
              this rule and successfully parsed before, then seek ahead to
              1 past the stop token matched for this rule last time.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Memoize(Antlr.Runtime.IIntStream,System.Int32,System.Int32)">
            <summary>
            Record whether or not this rule parsed the input at this position
            successfully.  Use a standard java hashtable for now.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleMemoizationCacheSize">
            <summary>return how many rule/input-index pairs there are in total.</summary>
            TODO: this includes synpreds. :(
        </member>
        <member name="T:Antlr.Runtime.BitSet">
            <summary>
            A stripped-down version of org.antlr.misc.BitSet that is just
            good enough to handle runtime requirements such as FOLLOW sets
            for automatic error recovery.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.BitSet.MOD_MASK">
            <summary>
            We will often need to do a mod operator (i mod nbits).  Its
            turns out that, for powers of two, this mod operation is
            same as (i &amp; (nbits-1)).  Since mod is slow, we use a
            precomputed mod mask to do the mod instead.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.BitSet._bits">
            <summary>The actual data bits</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor">
            <summary>Construct a bitset of size one word (64 bits)</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor(System.UInt64[])">
            <summary>Construction from a static array of longs</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>Construction from a list of integers</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor(System.Int32)">
            <summary>Construct a bitset given the size</summary>
            <param name="nbits">The size of the bitset in bits</param>
        </member>
        <member name="M:Antlr.Runtime.BitSet.Or(Antlr.Runtime.BitSet)">
            <summary>return this | a in a new set</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.Add(System.Int32)">
            <summary>or this element into this set (grow as necessary to accommodate)</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.GrowToInclude(System.Int32)">
            <summary>Grows the set to a larger number of bits.</summary>
            <param name="bit">element that must fit in set</param>
        </member>
        <member name="M:Antlr.Runtime.BitSet.SetSize(System.Int32)">
            <summary>Sets the size of a set.</summary>
            <param name="nwords">how many words the new set should be</param>
        </member>
        <member name="M:Antlr.Runtime.BitSet.LengthInLongWords">
            <summary>return how much space is being used by the bits array not how many actually have member bits on.</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.ToArray">
            Is this contained within a? 
        </member>
        <member name="T:Antlr.Runtime.BufferedTokenStream">
            Buffer all input tokens but do on-demand fetching of new tokens from
              lexer. Useful when the parser or lexer has to set context/mode info before
              proper lexing of future tokens. The ST template parser needs this,
              for example, because it has to constantly flip back and forth between
              inside/output templates. E.g., <c>&lt;names:{hi, &lt;it&gt;}&gt;</c> has to parse names
              as part of an expression but "hi, &lt;it&gt;" as a nested template.
            
              You can't use this stream if you pass whitespace or other off-channel
              tokens to the parser. The stream can't ignore off-channel tokens.
              (UnbufferedTokenStream is the same way.)
            
              This is not a subclass of UnbufferedTokenStream because I don't want
              to confuse small moving window of tokens it uses for the full buffer.
        </member>
        <member name="F:Antlr.Runtime.BufferedTokenStream._tokens">
            Record every single token pulled from the source so we can reproduce
            chunks of it later.  The buffer in LookaheadStream overlaps sometimes
            as its moving window moves through the input.  This list captures
            everything so we can access complete input text.
        </member>
        <member name="F:Antlr.Runtime.BufferedTokenStream._lastMarker">
            Track the last mark() call result value for use in rewind(). 
        </member>
        <member name="F:Antlr.Runtime.BufferedTokenStream._p">
            The index into the tokens list of the current token (next token
            to consume).  tokens[p] should be LT(1).  p=-1 indicates need
            to initialize with first token.  The ctor doesn't get a token.
            First call to LT(1) or whatever gets the first token and sets p=0;
        </member>
        <member name="P:Antlr.Runtime.BufferedTokenStream.Range">
            <summary>
            How deep have we gone?
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.Consume">
            Move the input pointer to the next incoming token.  The stream
              must become active with LT(1) available.  consume() simply
              moves the input pointer so that LT(1) points at the next
              input symbol. Consume at least one token.
            
              Walk past any token not on the channel the parser is listening to.
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.Sync(System.Int32)">
            Make sure index i in tokens has a token. 
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.Fetch(System.Int32)">
            add n elements to buffer 
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.GetTokens(System.Int32,System.Int32,Antlr.Runtime.BitSet)">
            Given a start and stop index, return a List of all tokens in
            the token type BitSet.  Return null if no tokens were found.  This
            method looks at both on and off channel tokens.
        </member>
        <member name="T:Antlr.Runtime.CharStreamState">
            <summary>
              When walking ahead with cyclic DFA or for syntactic predicates,
              we need to record the state of the input stream (char index,
              line, etc...) so that we can rewind the state after scanning ahead.
              </summary>
            
              <remarks>This is the complete state of a stream.</remarks>
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.p">
            <summary>Index into the char stream of next lookahead char</summary> 
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.line">
            <summary>What line number is the scanner at before processing buffer[p]?</summary> 
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.charPositionInLine">
            <summary>What char position 0..n-1 in line is scanner before processing buffer[p]?</summary> 
        </member>
        <member name="T:Antlr.Runtime.ClassicToken">
            <summary>
            A Token object like we'd use in ANTLR 2.x; has an actual string created
            and associated with this object.  These objects are needed for imaginary
            tree nodes that have payload objects.  We need to create a Token object
            that has a string; the tree node will point at this token.  CommonToken
            has indexes into a char stream and hence cannot be used to introduce
            new strings.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ClassicToken.index">
            <summary>What token number is this from 0..n-1 tokens</summary> 
        </member>
        <member name="F:Antlr.Runtime.CommonToken.text">
            <summary>
            We need to be able to change the text once in a while.  If
            this is non-null, then getText should return this.  Note that
            start/stop are not affected by changing this.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonToken.index">
            <summary>What token number is this from 0..n-1 tokens; &lt; 0 implies invalid index</summary> 
        </member>
        <member name="F:Antlr.Runtime.CommonToken.start">
            <summary>The char position into the input buffer where this token starts</summary> 
        </member>
        <member name="F:Antlr.Runtime.CommonToken.stop">
            <summary>The char position into the input buffer where this token stops</summary> 
        </member>
        <member name="T:Antlr.Runtime.CommonTokenStream">
            <summary>
              The most common stream of tokens is one where every token is buffered up
              and tokens are prefiltered for a certain channel (the parser will only
              see these tokens and cannot change the filter channel number during the
              parse).
              </summary>
            
              <remarks>TODO: how to access the full token stream?  How to track all tokens matched per rule?</remarks>
        </member>
        <member name="F:Antlr.Runtime.CommonTokenStream._channel">
            Skip tokens on any channel but this one; this is how we skip whitespace... 
        </member>
        <member name="P:Antlr.Runtime.CommonTokenStream.TokenSource">
            Reset this token stream by setting its token source. 
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.Consume">
            Always leave p on an on-channel token. 
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.SkipOffTokenChannels(System.Int32)">
            Given a starting index, return the index of the first on-channel
            token.
        </member>
        <member name="T:Antlr.Runtime.Debug.IDebugEventListener">
            <summary>All debugging events that a recognizer can trigger.</summary>
            
              <remarks>
              I did not create a separate AST debugging interface as it would create
              lots of extra classes and DebugParser has a dbg var defined, which makes
              it hard to change to ASTDebugEventListener.  I looked hard at this issue
              and it is easier to understand as one monolithic event interface for all
              possible events.  Hopefully, adding ST debugging stuff won't be bad.  Leave
              for future. 4/26/2006.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterRule(System.String,System.String)">
            <summary>
            The parser has just entered a rule.  No decision has been made about
            which alt is predicted.  This is fired AFTER init actions have been
            executed.  Attributes are defined and available etc...
            The grammarFileName allows composite grammars to jump around among
            multiple grammar files.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterAlt(System.Int32)">
            <summary>
            Because rules can have lots of alternatives, it is very useful to
            know which alt you are entering.  This is 1..n for n alts.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ExitRule(System.String,System.String)">
            <summary>
            This is the last thing executed before leaving a rule.  It is
            executed even if an exception is thrown.  This is triggered after
            error reporting and recovery have occurred (unless the exception is
            not caught in this rule).  This implies an "exitAlt" event.
            The grammarFileName allows composite grammars to jump around among
            multiple grammar files.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterSubRule(System.Int32)">
            <summary>Track entry into any (...) subrule other EBNF construct</summary> 
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterDecision(System.Int32,System.Boolean)">
            <summary>
            Every decision, fixed k or arbitrary, has an enter/exit event
            so that a GUI can easily track what LT/consume events are
            associated with prediction.  You will see a single enter/exit
            subrule but multiple enter/exit decision events, one for each
            loop iteration.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ConsumeToken(Antlr.Runtime.IToken)">
            <summary>
            An input token was consumed; matched by any kind of element.
            Trigger after the token was matched by things like match(), matchAny().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ConsumeHiddenToken(Antlr.Runtime.IToken)">
            <summary>
            An off-channel input token was consumed.
            Trigger after the token was matched by things like match(), matchAny().
            (unless of course the hidden token is first stuff in the input stream).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.LT(System.Int32,Antlr.Runtime.IToken)">
            <summary>
            Somebody (anybody) looked ahead.  Note that this actually gets
            triggered by both LA and LT calls.  The debugger will want to know
            which Token object was examined.  Like consumeToken, this indicates
            what token was seen at that depth.  A remote debugger cannot look
            ahead into a file it doesn't have so LT events must pass the token
            even if the info is redundant.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Mark(System.Int32)">
            <summary>
            The parser is going to look arbitrarily ahead; mark this location,
            the token stream's marker is sent in case you need it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Rewind(System.Int32)">
            <summary>
            After an arbitrairly long lookahead as with a cyclic DFA (or with
            any backtrack), this informs the debugger that stream should be
            rewound to the position associated with marker.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Rewind">
            <summary>
            Rewind to the input position of the last marker.
            Used currently only after a cyclic DFA and just
            before starting a sem/syn predicate to get the
            input position back to the start of the decision.
            Do not "pop" the marker off the state.  mark(i)
            and rewind(i) should balance still.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Location(System.Int32,System.Int32)">
            <summary>
              To watch a parser move through the grammar, the parser needs to
              inform the debugger what line/charPos it is passing in the grammar.
              For now, this does not know how to switch from one grammar to the
              other and back for island grammars etc...
              </summary>
            
              <remarks>
              This should also allow breakpoints because the debugger can stop
              the parser whenever it hits this line/pos.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.RecognitionException(Antlr.Runtime.RecognitionException)">
            <summary>
              A recognition exception occurred such as NoViableAltException.  I made
              this a generic event so that I can alter the exception hierachy later
              without having to alter all the debug objects.
              </summary>
            
              <remarks>
              Upon error, the stack of enter rule/subrule must be properly unwound.
              If no viable alt occurs it is within an enter/exit decision, which
              also must be rewound.  Even the rewind for each mark must be unwount.
              In the Java target this is pretty easy using try/finally, if a bit
              ugly in the generated code.  The rewind is generated in DFA.predict()
              actually so no code needs to be generated for that.  For languages
              w/o this "finally" feature (C++?), the target implementor will have
              to build an event stack or something.
            
              Across a socket for remote debugging, only the RecognitionException
              data fields are transmitted.  The token object or whatever that
              caused the problem was the last object referenced by LT.  The
              immediately preceding LT event should hold the unexpected Token or
              char.
            
              Here is a sample event trace for grammar:
            
              b : C ({;}A|B) // {;} is there to prevent A|B becoming a set
                | D
                ;
            
              The sequence for this rule (with no viable alt in the subrule) for
              input 'c c' (there are 3 tokens) is:
            
            		commence
            		LT(1)
            		enterRule b
            		location 7 1
            		enter decision 3
            		LT(1)
            		exit decision 3
            		enterAlt1
            		location 7 5
            		LT(1)
            		consumeToken [c/&lt;4&gt;,1:0]
            		location 7 7
            		enterSubRule 2
            		enter decision 2
            		LT(1)
            		LT(1)
            		recognitionException NoViableAltException 2 1 2
            		exit decision 2
            		exitSubRule 2
            		beginResync
            		LT(1)
            		consumeToken [c/&lt;4&gt;,1:1]
            		LT(1)
            		endResync
            		LT(-1)
            		exitRule b
            		terminate
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.BeginResync">
            <summary>
            Indicates the recognizer is about to consume tokens to resynchronize
            the parser.  Any consume events from here until the recovered event
            are not part of the parse--they are dead tokens.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EndResync">
            <summary>
            Indicates that the recognizer has finished consuming tokens in order
            to resychronize.  There may be multiple beginResync/endResync pairs
            before the recognizer comes out of errorRecovery mode (in which
            multiple errors are suppressed).  This will be useful
            in a gui where you want to probably grey out tokens that are consumed
            but not matched to anything in grammar.  Anything between
            a beginResync/endResync pair was tossed out by the parser.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.SemanticPredicate(System.Boolean,System.String)">
            <summary>A semantic predicate was evaluate with this result and action text</summary> 
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Commence">
            <summary>
            Announce that parsing has begun.  Not technically useful except for
            sending events over a socket.  A GUI for example will launch a thread
            to connect and communicate with a remote parser.  The thread will want
            to notify the GUI when a connection is made.  ANTLR parsers
            trigger this upon entry to the first rule (the ruleLevel is used to
            figure this out).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Terminate">
            <summary>
            Parsing is over; successfully or not.  Mostly useful for telling
            remote debugging listeners that it's time to quit.  When the rule
            invocation level goes to zero at the end of a rule, we are done
            parsing.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ConsumeNode(System.Object)">
            <summary>
              Input for a tree parser is an AST, but we know nothing for sure
              about a node except its type and text (obtained from the adaptor).
              This is the analog of the consumeToken method.  Again, the ID is
              the hashCode usually of the node so it only works if hashCode is
              not implemented.  If the type is UP or DOWN, then
              the ID is not really meaningful as it's fixed--there is
              just one UP node and one DOWN navigation node.
              </summary>
            
              <param name="t" />
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.LT(System.Int32,System.Object)">
            <summary>
            The tree parser lookedahead.  If the type is UP or DOWN,
            then the ID is not really meaningful as it's fixed--there is
            just one UP node and one DOWN navigation node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.NilNode(System.Object)">
            <summary>
              A nil was created (even nil nodes have a unique ID...
              they are not "null" per se).  As of 4/28/2006, this
              seems to be uniquely triggered when starting a new subtree
              such as when entering a subrule in automatic mode and when
              building a tree in rewrite mode.
              </summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only t.ID is set.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ErrorNode(System.Object)">
            <summary>
              Upon syntax error, recognizers bracket the error with an error node
              if they are building ASTs.
              </summary>
            
              <param name="t"/>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.CreateNode(System.Object)">
            <summary>Announce a new node built from token elements such as type etc...</summary>
            
             <remarks>
             If you are receiving this event over a socket via
             RemoteDebugEventSocketListener then only t.ID, type, text are
             set.
             </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.CreateNode(System.Object,Antlr.Runtime.IToken)">
            <summary>Announce a new node built from an existing token.</summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only node.ID and token.tokenIndex
              are set.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.BecomeRoot(System.Object,System.Object)">
            <summary>Make a node the new root of an existing root.  See</summary>
            
              <remarks>
              Note: the newRootID parameter is possibly different
              than the TreeAdaptor.becomeRoot() newRoot parameter.
              In our case, it will always be the result of calling
              TreeAdaptor.becomeRoot() and not root_n or whatever.
            
              The listener should assume that this event occurs
              only when the current subrule (or rule) subtree is
              being reset to newRootID.
             
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only IDs are set.
              </remarks>
            
              <seealso cref="M:Antlr.Runtime.Tree.ITreeAdaptor.BecomeRoot(System.Object,System.Object)"/>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.AddChild(System.Object,System.Object)">
            <summary>Make childID a child of rootID.</summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only IDs are set.
              </remarks>
            
              <seealso cref="M:Antlr.Runtime.Tree.ITreeAdaptor.AddChild(System.Object,System.Object)"/>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.SetTokenBoundaries(System.Object,System.Int32,System.Int32)">
            <summary>Set the token start/stop token index for a subtree root or node.</summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only t.ID is set.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.DFA">
            <summary>A DFA implemented as a set of transition tables.</summary>
            
              <remarks>
              Any state that has a semantic predicate edge is special; those states
              are generated with if-then-else structures in a specialStateTransition()
              which is generated by cyclicDFA template.
            
              There are at most 32767 states (16-bit signed short).
              Could get away with byte sometimes but would have to generate different
              types and the simulation code too.  For a point of reference, the Java
              lexer's Tokens rule DFA has 326 states roughly.
              </remarks>
        </member>
        <member name="F:Antlr.Runtime.DFA.recognizer">
            <summary>Which recognizer encloses this DFA?  Needed to check backtracking</summary> 
        </member>
        <member name="M:Antlr.Runtime.DFA.Predict(Antlr.Runtime.IIntStream)">
            <summary>
            From the input stream, predict what alternative will succeed
            using this DFA (representing the covering regular approximation
            to the underlying CFL).  Return an alternative number 1..n.  Throw
            an exception upon error.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.DFA.Error(Antlr.Runtime.NoViableAltException)">
            <summary>A hook for debugging interface</summary> 
        </member>
        <member name="M:Antlr.Runtime.DFA.UnpackEncodedString(System.String)">
            <summary>
            Given a String that has a run-length-encoding of some unsigned shorts
            like "\1\2\3\9", convert to short[] {2,9,9,9}.  We do this to avoid
            static short[] which generates so much init code that the class won't
            compile. :(
            </summary>
        </member>
        <member name="M:Antlr.Runtime.DFA.UnpackEncodedStringToUnsignedChars(System.String)">
            <summary>Hideous duplication of code, but I need different typed arrays out :(</summary> 
        </member>
        <member name="T:Antlr.Runtime.EarlyExitException">
            <summary>The recognizer did not match anything for a (..)+ loop.</summary> 
        </member>
        <member name="T:Antlr.Runtime.FailedPredicateException">
            <summary>
            A semantic predicate failed during validation.  Validation of predicates
            occurs when normally parsing the alternative just like matching a token.
            Disambiguating predicate evaluation occurs when we hoist a predicate into
            a prediction decision.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.IAstRuleReturnScope">
            <summary>AST rules have trees</summary> 
        </member>
        <member name="P:Antlr.Runtime.IAstRuleReturnScope.Tree">
            <summary>Has a value potentially if output=AST;</summary> 
        </member>
        <member name="T:Antlr.Runtime.IAstRuleReturnScope`1">
            <summary>AST rules have trees</summary> 
        </member>
        <member name="P:Antlr.Runtime.IAstRuleReturnScope`1.Tree">
            <summary>Has a value potentially if output=AST;</summary> 
        </member>
        <member name="T:Antlr.Runtime.ICharStream">
            <summary>A source of characters for an ANTLR lexer</summary> 
        </member>
        <member name="M:Antlr.Runtime.ICharStream.Substring(System.Int32,System.Int32)">
            <summary>
            For infinite streams, you don't need this; primarily I'm providing
            a useful interface for action code.  Just make sure actions don't
            use this on streams that don't support it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ICharStream.LT(System.Int32)">
            <summary>
            Get the ith character of lookahead.  This is the same usually as
            LA(i).  This will be used for labels in the generated
            lexer code.  I'd prefer to return a char here type-wise, but it's
            probably better to be 32-bit clean and be consistent with LA.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ICharStream.Line">
            <summary>ANTLR tracks the line information automatically</summary> 
            <summary>Because this stream can rewind, we need to be able to reset the line</summary> 
        </member>
        <member name="P:Antlr.Runtime.ICharStream.CharPositionInLine">
            <summary>The index of the character relative to the beginning of the line 0..n-1</summary> 
        </member>
        <member name="T:Antlr.Runtime.IIntStream">
            <summary>
            A simple stream of integers used when all I care about is the char
            or token type sequence (such as interpretation).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.LA(System.Int32)">
            <summary>
            Get int at current input pointer + i ahead where i=1 is next int.
            Negative indexes are allowed.  LA(-1) is previous token (token
            just matched).  LA(-i) where i is before first token should
            yield -1, invalid char / EOF.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Mark">
            <summary>
            Tell the stream to start buffering if it hasn't already.  Return
            current input position, Index, or some other marker so that
            when passed to rewind() you get back to the same spot.
            rewind(mark()) should not affect the input cursor.  The Lexer
            track line/col info as well as input index so its markers are
            not pure input indexes.  Same for tree node streams.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IIntStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.  The index is the symbol about to be
            read not the most recently read symbol.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Rewind(System.Int32)">
            <summary>
            Reset the stream so that next call to index would return marker.
            The marker will usually be Index but it doesn't have to be.  It's
            just a marker to indicate what state the stream was in.  This is
            essentially calling release() and seek().  If there are markers
            created after this marker argument, this routine must unroll them
            like a stack.  Assume the state the stream was in when this marker
            was created.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Rewind">
            <summary>
            Rewind to the input position of the last marker.
            Used currently only after a cyclic DFA and just
            before starting a sem/syn predicate to get the
            input position back to the start of the decision.
            Do not "pop" the marker off the state.  mark(i)
            and rewind(i) should balance still. It is
            like invoking rewind(last marker) but it should not "pop"
            the marker off.  It's like seek(last marker's input position).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Release(System.Int32)">
            <summary>
            You may want to commit to a backtrack but don't want to force the
            stream to keep bookkeeping objects around for a marker that is
            no longer necessary.  This will have the same behavior as
            rewind() except it releases resources without the backward seek.
            This must throw away resources for all markers back to the marker
            argument.  So if you're nested 5 levels of mark(), and then release(2)
            you have to release resources for depths 2..5.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Seek(System.Int32)">
            <summary>
              Set the input cursor to the position indicated by index.  This is
              normally used to seek ahead in the input stream.  No buffering is
              required to do this unless you know your stream will use seek to
              move backwards such as when backtracking.
              </summary>
            
              <remarks>
              This is different from rewind in its multi-directional
              requirement and in that its argument is strictly an input cursor (index).
            
              For char streams, seeking forward must update the stream state such
              as line number.  For seeking backwards, you will be presumably
              backtracking using the mark/rewind mechanism that restores state and
              so this method does not need to update state when seeking backwards.
            
              Currently, this method is only used for efficient backtracking using
              memoization, but in the future it may be used for incremental parsing.
            
              The index is 0..n-1.  A seek to position i means that LA(1) will
              return the ith symbol.  So, seeking to 0 means LA(1) will return the
              first element in the stream. 
              </remarks>
        </member>
        <member name="P:Antlr.Runtime.IIntStream.Count">
            <summary>
            Only makes sense for streams that buffer everything up probably, but
            might be useful to display the entire stream or for testing.  This
            value includes a single EOF.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IIntStream.SourceName">
            <summary>
            Where are you getting symbols from?  Normally, implementations will
            pass the buck all the way to the lexer who can ask its input stream
            for the file name or whatever.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.IRuleReturnScope">
            <summary>
            Rules can have start/stop info.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IRuleReturnScope.Start">
            <summary>
            Gets the start element from the input stream
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IRuleReturnScope.Stop">
            <summary>
            Gets the stop element from the input stream
            </summary>
        </member>
        <member name="T:Antlr.Runtime.IRuleReturnScope`1">
            <summary>
            Rules can have start/stop info.
            </summary>
            <typeparam name="TLabel">The element type of the input stream.</typeparam>
        </member>
        <member name="P:Antlr.Runtime.IRuleReturnScope`1.Start">
            <summary>
            Gets the start element from the input stream
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IRuleReturnScope`1.Stop">
            <summary>
            Gets the stop element from the input stream
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IToken.Text">
            <summary>Get the text of the token</summary> 
        </member>
        <member name="P:Antlr.Runtime.IToken.Line">
            <summary>The line number on which this token was matched; line=1..n</summary> 
        </member>
        <member name="P:Antlr.Runtime.IToken.CharPositionInLine">
            <summary>The index of the first character relative to the beginning of the line 0..n-1</summary> 
        </member>
        <member name="P:Antlr.Runtime.IToken.TokenIndex">
            <summary>
            An index from 0..n-1 of the token object in the input stream.
            This must be valid in order to use the ANTLRWorks debugger.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IToken.InputStream">
            <summary>
            From what character stream was this token created?  You don't have to
            implement but it's nice to know where a Token comes from if you have
            include files etc... on the input.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ITokenSource">
            <summary>
              A source of tokens must provide a sequence of tokens via nextToken()
              and also must reveal it's source of characters; CommonToken's text is
              computed from a CharStream; it only store indices into the char stream.
              </summary>
            
              <remarks>
              Errors from the lexer are never passed to the parser.  Either you want
              to keep going or you do not upon token recognition error.  If you do not
              want to continue lexing then you do not want to continue parsing.  Just
              throw an exception not under RecognitionException and Java will naturally
              toss you all the way out of the recognizers.  If you want to continue
              lexing then you should not throw an exception to the parser--it has already
              requested a token.  Keep lexing until you get a valid one.  Just report
              errors and keep going, looking for a valid token.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.ITokenSource.NextToken">
            <summary>
            Return a Token object from your input stream (usually a CharStream).
            Do not fail/return upon lexing error; keep chewing on the characters
            until you get a good one; errors are not passed through to the parser.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ITokenSource.SourceName">
            <summary>
            Where are you getting tokens from? normally the implication will simply
            ask lexers input stream.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ITokenStream">
            <summary>A stream of tokens accessing tokens from a TokenSource</summary> 
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.LT(System.Int32)">
            <summary>Get Token at current input pointer + i ahead where i=1 is next Token.
            i&lt;0 indicates tokens in the past.  So -1 is previous token and -2 is
            two tokens ago. LT(0) is undefined.  For i&gt;=n, return Token.EOFToken.
            Return null for LT(0) and any index that results in an absolute address
            that is negative.</summary>
        </member>
        <member name="P:Antlr.Runtime.ITokenStream.Range">
            <summary>
            How far ahead has the stream been asked to look?  The return
            value is a valid index from 0..n-1.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.Get(System.Int32)">
            <summary>
            Get a token at an absolute index i; 0..n-1.  This is really only
            needed for profiling and debugging and token stream rewriting.
            If you don't want to buffer up tokens, then this method makes no
            sense for you.  Naturally you can't use the rewrite stream feature.
            I believe DebugTokenStream can easily be altered to not use
            this method, removing the dependency.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ITokenStream.TokenSource">
            <summary>
            Where is this stream pulling tokens from?  This is not the name, but
            the object that provides Token objects.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.ToString(System.Int32,System.Int32)">
            <summary>
            Return the text of all tokens from start to stop, inclusive.
            If the stream does not buffer all the tokens then it can just
            return "" or null;  Users should not access $ruleLabel.text in
            an action of course in that case.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.ToString(Antlr.Runtime.IToken,Antlr.Runtime.IToken)">
            <summary>
            Because the user is not required to use a token with an index stored
            in it, we must provide a means for two token objects themselves to
            indicate the start/end location.  Most often this will just delegate
            to the other toString(int,int).  This is also parallel with
            the TreeNodeStream.toString(Object,Object).
            </summary>
        </member>
        <member name="T:Antlr.Runtime.LegacyCommonTokenStream">
            <summary>
              The most common stream of tokens is one where every token is buffered up
              and tokens are prefiltered for a certain channel (the parser will only
              see these tokens and cannot change the filter channel number during the
              parse).
              </summary>
            
              <remarks>TODO: how to access the full token stream?  How to track all tokens matched per rule?</remarks>
        </member>
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.tokens">
            <summary>
            Record every single token pulled from the source so we can reproduce
            chunks of it later.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.channelOverrideMap">
            <summary>Map from token type to channel to override some Tokens' channel numbers</summary> 
        </member>
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.discardSet">
            <summary>Set of token types; discard any tokens with this type</summary> 
        </member>
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.channel">
            <summary>Skip tokens on any channel but this one; this is how we skip whitespace...</summary> 
        </member>
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.discardOffChannelTokens">
            <summary>By default, track all incoming tokens</summary> 
        </member>
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="F:Antlr.Runtime.LegacyCommonTokenStream.p">
            <summary>
            The index into the tokens list of the current token (next token
            to consume).  p==-1 indicates that the tokens list is empty
            </summary>
        </member>
        <member name="P:Antlr.Runtime.LegacyCommonTokenStream.Range">
            <summary>
            How deep have we gone?
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.SetTokenSource(Antlr.Runtime.ITokenSource)">
            <summary>Reset this token stream by setting its token source.</summary> 
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.FillBuffer">
            <summary>
            Load all tokens from the token source and put in tokens.
            This is done upon first LT request because you might want to
            set some token type / channel overrides before filling buffer.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.Consume">
            <summary>
              Move the input pointer to the next incoming token.  The stream
              must become active with LT(1) available.  consume() simply
              moves the input pointer so that LT(1) points at the next
              input symbol. Consume at least one token.
              </summary>
            
              <remarks>
              Walk past any token not on the channel the parser is listening to.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.SkipOffTokenChannels(System.Int32)">
            <summary>Given a starting index, return the index of the first on-channel token.</summary> 
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.SetTokenTypeChannel(System.Int32,System.Int32)">
            <summary>
            A simple filter mechanism whereby you can tell this token stream
            to force all tokens of type ttype to be on channel.  For example,
            when interpreting, we cannot exec actions so we need to tell
            the stream to force all WS and NEWLINE to be a different, ignored
            channel.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.GetTokens(System.Int32,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
            Given a start and stop index, return a List of all tokens in
            the token type BitSet.  Return null if no tokens were found.  This
            method looks at both on and off channel tokens.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.LT(System.Int32)">
            <summary>
            Get the ith token from the current position 1..n where k=1 is the
            first symbol of lookahead.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.LB(System.Int32)">
            <summary>Look backwards k tokens on-channel tokens</summary> 
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.Get(System.Int32)">
            <summary>
            Return absolute token i; ignore which channel the tokens are on;
            that is, count all tokens not just on-channel tokens.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Lexer">
            <summary>
            A lexer is recognizer that draws input symbols from a character stream.
            lexer grammars result in a subclass of this object. A Lexer object
            uses simplified match() and error recovery mechanisms in the interest
            of speed.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Lexer.input">
            <summary>Where is the lexer drawing characters from?</summary> 
        </member>
        <member name="P:Antlr.Runtime.Lexer.Text">
            <summary>
            Gets or sets the text matched so far for the current token or any text override.
            </summary>
            <remarks>
            <para>Setting this value replaces any previously set value, and overrides the original text.</para>
            </remarks>
        </member>
        <member name="M:Antlr.Runtime.Lexer.NextToken">
            <summary>Return a token from this source; i.e., match a token on the char stream.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Lexer.GetEndOfFileToken">
            Returns the EOF token (default), if you need
            to return a custom token instead override this method.
        </member>
        <member name="M:Antlr.Runtime.Lexer.Skip">
            <summary>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.  nextToken() knows to keep looking when
            a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
            if token==null at end of any token rule, it creates one for you
            and emits it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Lexer.mTokens">
            <summary>This is the lexer entry point that sets instance var 'token'</summary> 
        </member>
        <member name="M:Antlr.Runtime.Lexer.Emit(Antlr.Runtime.IToken)">
            <summary>
            Currently does not support multiple emits per nextToken invocation
            for efficiency reasons.  Subclass and override this method and
            nextToken (to push tokens into a list and pull from that list rather
            than a single variable as this implementation does).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Lexer.Emit">
            <summary>
              The standard method called to automatically emit a token at the
              outermost lexical rule.  The token object should point into the
              char buffer start..stop.  If there is a text override in 'text',
              use that to set the token's text.  Override this method to emit
              custom Token objects.
              </summary>
            
              <remarks>
              If you are building trees, then you should also override
              Parser or TreeParser.getMissingSymbol().
              </remarks>
        </member>
        <member name="P:Antlr.Runtime.Lexer.CharIndex">
            <summary>What is the index of the current character of lookahead?</summary> 
        </member>
        <member name="M:Antlr.Runtime.Lexer.Recover(Antlr.Runtime.RecognitionException)">
            <summary>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.  You can instead use the rule invocation stack
            to do sophisticated error recovery if you are in a fragment rule.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Misc.FastQueue`1">
            A queue that can dequeue and get(i) in O(1) and grow arbitrarily large.
              A linked list is fast at dequeue but slow at get(i).  An array is
              the reverse.  This is O(1) for both operations.
            
              List grows until you dequeue last element at end of buffer. Then
              it resets to start filling at 0 again.  If adds/removes are balanced, the
              buffer will not grow too large.
            
              No iterator stuff as that's not how we'll use it.
        </member>
        <member name="F:Antlr.Runtime.Misc.FastQueue`1._data">
            <summary>dynamically-sized buffer of elements</summary> 
        </member>
        <member name="F:Antlr.Runtime.Misc.FastQueue`1._p">
            <summary>index of next element to fill</summary> 
        </member>
        <member name="P:Antlr.Runtime.Misc.FastQueue`1.Range">
            <summary>
            How deep have we gone?
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Misc.FastQueue`1.Item(System.Int32)">
            <summary>
            Return element {@code i} elements ahead of current element. {@code i==0}
            gets current element. This is not an absolute index into {@link #data}
            since {@code p} defines the start of the real list.
             </summary>
        </member>
        <member name="M:Antlr.Runtime.Misc.FastQueue`1.Dequeue">
            <summary>Get and remove first element in queue</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.FastQueue`1.ToString">
            <summary>Return string of current buffer contents; non-destructive</summary> 
        </member>
        <member name="T:Antlr.Runtime.Misc.LookaheadStream`1">
            <summary>
            A lookahead queue that knows how to mark/release locations in the buffer for
            backtracking purposes. Any markers force the {@link FastQueue} superclass to
            keep all elements until no more markers; then can reset to avoid growing a
            huge buffer.
             </summary>
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._currentElementIndex">
            Absolute token index. It's the index of the symbol about to be
            read via {@code LT(1)}. Goes from 0 to numtokens.
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._previousElement">
            This is the {@code LT(-1)} element for the first element in {@link #data}.
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._eof">
            Track object returned by nextElement upon end of stream;
            Return it later when they ask for LT passed end of input.
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._markDepth">
            <summary>tracks how deep mark() calls are nested</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.NextElement">
            <summary>
            Implement nextElement to supply a stream of elements to this
            lookahead buffer.  Return EOF upon end of the stream we're pulling from.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Dequeue">
            <summary>
            Get and remove first element in queue; override
            {@link FastQueue#remove()}; it's the same, just checks for backtracking.
            </summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Consume">
            <summary>Make sure we have at least one element to remove, even if EOF</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.SyncAhead(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position p. Last valid
            p index is data.size()-1.  p+need-1 is the data index 'need' elements
            ahead.  If we need 1 element, (p+1-1)==p must be &lt; data.size().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Fill(System.Int32)">
            <summary>add n elements to buffer</summary> 
        </member>
        <member name="P:Antlr.Runtime.Misc.LookaheadStream`1.Count">
            <summary>Size of entire stream is unknown; we only know buffer size from FastQueue</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Seek(System.Int32)">
            <summary>
            Seek to a 0-indexed absolute token index. Normally used to seek backwards
            in the buffer. Does not force loading of nodes.
             </summary>
             <remarks>
            To preserve backward compatibility, this method allows seeking past the
            end of the currently buffered data. In this case, the input pointer will
            be moved but the data will only actually be loaded upon the next call to
            {@link #consume} or {@link #LT} for {@code k>0}.
             </remarks>
        </member>
        <member name="T:Antlr.Runtime.MismatchedTokenException">
            <summary>A mismatched char or Token or tree node</summary> 
        </member>
        <member name="T:Antlr.Runtime.MissingTokenException">
            <summary>
            We were expecting a token but it's not found.  The current token
            is actually what we wanted next.  Used for tree node errors too.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Parser">
            <summary>
            A parser for TokenStreams.  "parser grammars" result in a subclass
            of this.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Parser.TokenStream">
            <summary>Gets or sets the token stream; resets the parser upon a set.</summary> 
        </member>
        <member name="T:Antlr.Runtime.ParserRuleReturnScope`1">
            <summary>
              Rules that return more than a single value must return an object
              containing all the values.  Besides the properties defined in
              RuleLabelScope.predefinedRulePropertiesScope there may be user-defined
              return values.  This class simply defines the minimum properties that
              are always defined and methods to access the others that might be
              available depending on output option such as template and tree.
              </summary>
            
              <remarks>
              Note text is not an actual property of the return value, it is computed
              from start and stop using the input stream's toString() method.  I
              could add a ctor to this so that we can pass in and store the input
              stream, but I'm not sure we want to do that.  It would seem to be undefined
              to get the .text property anyway if the rule matches tokens from multiple
              input streams.
            
              I do not use getters for fields of objects that are used simply to
              group values such as this aggregate.  The getters/setters are there to
              satisfy the superclass interface.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.RecognitionException">
            <summary>The root of the ANTLR exception hierarchy.</summary>
            
              <remarks>
              To avoid English-only error messages and to generally make things
              as flexible as possible, these exceptions are not created with strings,
              but rather the information necessary to generate an error.  Then
              the various reporting methods in Parser and Lexer can be overridden
              to generate a localized error message.  For example, MismatchedToken
              exceptions are built with the expected token type.
              So, don't expect getMessage() to return anything.
            
              Note that as of Java 1.4, you can access the stack trace, which means
              that you can compute the complete trace of rules from the start symbol.
              This gives you considerable context information with which to generate
              useful error messages.
            
              ANTLR generates code that throws exceptions upon recognition error and
              also generates code to catch these exceptions in each rule.  If you
              want to quit upon first error, you can turn off the automatic error
              handling mechanism using rulecatch action, but you still need to
              override methods mismatch and recoverFromMismatchSet.
            
              In general, the recognition exceptions can track where in a grammar a
              problem occurred and/or what was the expected input.  While the parser
              knows its state (such as current input symbol and line info) that
              state can change before the exception is reported so current token index
              is computed and stored at exception time.  From this info, you can
              perhaps print an entire line of input not just a single token, for example.
              Better to just say the recognizer had a problem and then let the parser
              figure out a fancy report.
              </remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._input">
            <summary>What input stream did the error occur in?</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._k">
            <summary>
            What was the lookahead index when this exception was thrown?
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._index">
            <summary>What is index of token/char were we looking at when the error occurred?</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._token">
            <summary>
            The current Token when an error occurred.  Since not all streams
            can retrieve the ith Token, we have to track the Token object.
            For parsers.  Even when it's a tree parser, token might be set.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._node">
            <summary>
            If this is a tree parser exception, node is set to the node with
            the problem.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._c">
            <summary>The current char when an error occurred. For lexers.</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._line">
            <summary>
            Track the line (1-based) at which the error occurred in case this is
            generated from a lexer.  We need to track this since the
            unexpected char doesn't carry the line info.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._charPositionInLine">
            <summary>
            The 0-based index into the line where the error occurred.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._approximateLineInfo">
            <summary>
            If you are parsing a tree node stream, you will encounter som
            imaginary nodes w/o line/col info.  We now search backwards looking
            for most recent token with line/col info, but notify getErrorHeader()
            that info is approximate.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.RecognitionException.#ctor">
            <summary>Used for remote debugger deserialization</summary> 
        </member>
        <member name="P:Antlr.Runtime.RecognitionException.UnexpectedType">
            <summary>Return the token type or char of the unexpected input element</summary> 
        </member>
        <member name="T:Antlr.Runtime.RecognizerSharedState">
            <summary>
              The set of fields needed by an abstract recognizer to recognize input
              and recover from errors etc...  As a separate state object, it can be
              shared among multiple grammars; e.g., when one grammar imports another.
              </summary>
            
              <remarks>
              These fields are publically visible but the actual state pointer per
              parser is protected.
              </remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.following">
            <summary>
            Track the set of token types that can follow any rule invocation.
            Stack grows upwards.  When it hits the max, it grows 2x in size
            and keeps going.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.errorRecovery">
            <summary>
            This is true when we see an error and before having successfully
            matched a token.  Prevents generation of more than one error message
            per error.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.lastErrorIndex">
            <summary>
             The index into the input stream where the last error occurred.
            	This is used to prevent infinite loops where an error is found
             but no token is consumed during recovery...another error is found,
             ad naseum.  This is a failsafe mechanism to guarantee that at least
             one token/tree node is consumed for two errors.
             </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.failed">
            <summary>
            In lieu of a return value, this indicates that a rule or token
            has failed to match.  Reset to false upon valid token match.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.syntaxErrors">
            <summary>Did the recognizer encounter a syntax error?  Track how many.</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.backtracking">
            <summary>
            If 0, no backtracking is going on.  Safe to exec actions etc...
            If >0 then it's the level of backtracking.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.ruleMemo">
            <summary>
              An array[size num rules] of dictionaries that tracks
              the stop token index for each rule.  ruleMemo[ruleIndex] is
              the memoization table for ruleIndex.  For key ruleStartIndex, you
              get back the stop token for associated rule or MEMO_RULE_FAILED.
              </summary>
            
              <remarks>This is only used if rule memoization is on (which it is by default).</remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.token">
            <summary>
            The goal of all lexer rules/methods is to create a token object.
            This is an instance variable as multiple rules may collaborate to
            create a single token.  nextToken will return this object after
            matching lexer rule(s).  If you subclass to allow multiple token
            emissions, then set this to the last token to be matched or
            something nonnull so that the auto token emit mechanism will not
            emit another token.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartCharIndex">
            <summary>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.  Set at
            the start of nextToken.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartLine">
            <summary>The line on which the first character of the token resides</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartCharPositionInLine">
            <summary>The character position of first character within the line</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.channel">
            <summary>The channel number for the current token</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.type">
            <summary>The token type for the current token</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.text">
            <summary>
            You can set the text for the current token to override what is in
            the input char buffer.  Use setText() or can set this instance var.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.TokenChannels.Default">
            <summary>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".  The parser tunes to a particular channel
            so that whitespace etc... can go to the parser on a "hidden" channel.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.TokenChannels.Hidden">
            <summary>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.TokenRewriteStream">
            Useful for dumping out the input stream after doing some
              augmentation or other manipulations.
            
              You can insert stuff, replace, and delete chunks.  Note that the
              operations are done lazily--only if you convert the buffer to a
              String.  This is very efficient because you are not moving data around
              all the time.  As the buffer of tokens is converted to strings, the
              toString() method(s) check to see if there is an operation at the
              current index.  If so, the operation is done and then normal String
              rendering continues on the buffer.  This is like having multiple Turing
              machine instruction streams (programs) operating on a single input tape. :)
            
              Since the operations are done lazily at toString-time, operations do not
              screw up the token index values.  That is, an insert operation at token
              index i does not change the index values for tokens i+1..n-1.
            
              Because operations never actually alter the buffer, you may always get
              the original token stream back without undoing anything.  Since
              the instructions are queued up, you can easily simulate transactions and
              roll back any changes if there is an error just by removing instructions.
              For example,
            
               CharStream input = new ANTLRFileStream("input");
               TLexer lex = new TLexer(input);
               TokenRewriteStream tokens = new TokenRewriteStream(lex);
               T parser = new T(tokens);
               parser.startRule();
            
             	 Then in the rules, you can execute
                  Token t,u;
                  ...
                  input.insertAfter(t, "text to put after t");}
             		input.insertAfter(u, "text after u");}
             		System.out.println(tokens.toString());
            
              Actually, you have to cast the 'input' to a TokenRewriteStream. :(
            
              You can also have multiple "instruction streams" and get multiple
              rewrites from a single pass over the input.  Just name the instruction
              streams and use that name again when printing the buffer.  This could be
              useful for generating a C file and also its header file--all from the
              same buffer:
            
                  tokens.insertAfter("pass1", t, "text to put after t");}
             		tokens.insertAfter("pass2", u, "text after u");}
             		System.out.println(tokens.toString("pass1"));
             		System.out.println(tokens.toString("pass2"));
            
              If you don't use named rewrite streams, a "default" stream is used as
              the first example shows.
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.RewriteOperation.instructionIndex">
            <summary>What index into rewrites List are we?</summary> 
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.RewriteOperation.index">
            <summary>Token buffer index.</summary> 
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.RewriteOperation.Execute(System.Text.StringBuilder)">
            <summary>
            Execute the rewrite operation by possibly adding to the buffer.
            Return the index of the next token to operate on.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.TokenRewriteStream.ReplaceOp">
            <summary>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.programs">
            <summary>
            You may have multiple, named streams of rewrite operations.
            I'm calling these things "programs."
            Maps String (name) -> rewrite (List)
            </summary>
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.lastRewriteTokenIndexes">
            <summary>Map String (program name) -> Integer index</summary> 
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.Rollback(System.String,System.Int32)">
            <summary>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream.  UNTESTED!
            </summary>
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.DeleteProgram(System.String)">
            <summary>Reset the program so that no instructions exist</summary> 
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.ReduceToSingleOperationPerIndex(System.Collections.Generic.IList{Antlr.Runtime.TokenRewriteStream.RewriteOperation})">
            We need to combine operations and report invalid operations (like
              overlapping replaces that are not completed nested).  Inserts to
              same index need to be combined etc...   Here are the cases:
            
              I.i.u I.j.v								leave alone, nonoverlapping
              I.i.u I.i.v								combine: Iivu
            
              R.i-j.u R.x-y.v	| i-j in x-y			delete first R
              R.i-j.u R.i-j.v							delete first R
              R.i-j.u R.x-y.v	| x-y in i-j			ERROR
              R.i-j.u R.x-y.v	| boundaries overlap	ERROR
            
              Delete special case of replace (text==null):
              D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
            
              I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
            											we're not deleting i)
              I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
              R.x-y.v I.i.u | i in x-y				ERROR
              R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
              R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
            
              I.i.u = insert u before op @ index i
              R.x-y.u = replace x-y indexed tokens with u
            
              First we need to examine replaces.  For any replace op:
            
             		1. wipe out any insertions before op within that range.
            		2. Drop any replace op before that is contained completely within
                     that range.
            		3. Throw exception upon boundary overlap with any previous replace.
            
              Then we can deal with inserts:
            
             		1. for any inserts to same index, combine even if not adjacent.
             		2. for any prior replace with same left boundary, combine this
                     insert with replace and delete this replace.
             		3. throw exception if index in same range as previous replace
            
              Don't actually delete; make op null in list. Easier to walk list.
              Later we can throw as we add to index -> op map.
            
              Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
              inserted stuff would be before the replace range.  But, if you
              add tokens in front of a method body '{' and then delete the method
              body, I think the stuff before the '{' you added should disappear too.
            
              Return a map from token index to operation.
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.GetKindOfOps(System.Collections.Generic.IList{Antlr.Runtime.TokenRewriteStream.RewriteOperation},System.Type,System.Int32)">
            <summary>Get all operations before an index of a particular kind</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tokens.Skip">
            <summary>
            In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
            will avoid creating a token for this symbol and try to fetch another.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.TokenTypes.Down">
            <summary>imaginary tree navigation type; traverse "get child" link</summary> 
        </member>
        <member name="F:Antlr.Runtime.TokenTypes.Up">
            <summary>imaginary tree navigation type; finish with a child list</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.BaseTree">
            <summary>
            A generic tree implementation with no payload.  You must subclass to
            actually have any user data.  ANTLR v3 uses a list of children approach
            instead of the child-sibling approach in v2.  A flat tree (a list) is
            an empty node whose children represent the list.  An empty, but
            non-null node is called "nil".
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.#ctor(Antlr.Runtime.Tree.ITree)">
            <summary>
            Create a new node from an existing node does nothing for BaseTree
            as there are no fields other than the children list, which cannot
            be copied as the children are not considered part of this node. 
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.BaseTree.Children">
            <summary>
            Get the children internal List; note that if you directly mess with
            the list, do so at your own risk.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.BaseTree.Parent">
            <summary>BaseTree doesn't track parent pointers.</summary> 
        </member>
        <member name="P:Antlr.Runtime.Tree.BaseTree.ChildIndex">
            <summary>BaseTree doesn't track child indexes.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.AddChild(Antlr.Runtime.Tree.ITree)">
            <summary>Add t as child of this node.</summary>
            
              <remarks>
              Warning: if t has no children, but child does
              and child isNil then this routine moves children to t via
              t.children = child.children; i.e., without copying the array.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.AddChildren(System.Collections.Generic.IEnumerable{Antlr.Runtime.Tree.ITree})">
            <summary>Add all elements of kids list as children of this node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.InsertChild(System.Int32,Antlr.Runtime.Tree.ITree)">
            Insert child t at child position i (0..n-1) by shifting children
            i+1..n-1 to the right one position. Set parent / indexes properly
            but does NOT collapse nil-rooted t's that come in here like addChild.
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.ReplaceChildren(System.Int32,System.Int32,System.Object)">
            <summary>
            Delete children from start to stop and replace with t even if t is
            a list (nil-root tree).  num of children can increase or decrease.
            For huge child lists, inserting children can force walking rest of
            children to set their childindex; could be slow.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.CreateChildrenList">
            <summary>Override in a subclass to change the impl of children list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.FreshenParentAndChildIndexes">
            <summary>Set the parent and child index values for all child of t</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.HasAncestor(System.Int32)">
            <summary>Walk upwards looking for ancestor with this token type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.GetAncestor(System.Int32)">
            <summary>Walk upwards and get first ancestor with this token type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.GetAncestors">
            <summary>
            Return a list of all ancestors of this node.  The first node of
            list is the root and the last is the parent of this node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.ToStringTree">
            <summary>Print out a whole tree not just a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.ToString">
            <summary>Override to say how a node (not a tree) should look as text</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.BaseTreeAdaptor">
            <summary>A TreeAdaptor that works with any Tree implementation.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BaseTreeAdaptor.treeToUniqueIDMap">
            <summary>
            System.identityHashCode() is not always unique; we have to
            track ourselves.  That's ok, it's only for debugging, though it's
            expensive: we have to create a hashtable with all tree nodes in it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.ErrorNode(Antlr.Runtime.ITokenStream,Antlr.Runtime.IToken,Antlr.Runtime.IToken,Antlr.Runtime.RecognitionException)">
            <summary>
              Create tree node that holds the start and stop tokens associated
              with an error.
              </summary>
            
              <remarks>
              If you specify your own kind of tree nodes, you will likely have to
              override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
              if no token payload but you might have to set token type for diff
              node type.
            
              You don't have to subclass CommonErrorNode; you will likely need to
              subclass your own tree node class to avoid class cast exception.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.DupTree(System.Object,System.Object)">
            <summary>
            This is generic in the sense that it will work with any kind of
            tree (not just ITree interface).  It invokes the adaptor routines
            not the tree node routines to do the construction.  
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.AddChild(System.Object,System.Object)">
            <summary>
            Add a child to the tree t.  If child is a flat tree (a list), make all
            in list children of t.  Warning: if t has no children, but child does
            and child isNil then you can decide it is ok to move children to t via
            t.children = child.children; i.e., without copying the array.  Just
            make sure that this is consistent with have the user will build
            ASTs.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.BecomeRoot(System.Object,System.Object)">
            <summary>
              If oldRoot is a nil root, just copy or move the children to newRoot.
              If not a nil root, make oldRoot a child of newRoot.
              </summary>
            
              <remarks>
                old=^(nil a b c), new=r yields ^(r a b c)
                old=^(a b c), new=r yields ^(r ^(a b c))
            
              If newRoot is a nil-rooted single child tree, use the single
              child as the new root node.
            
                old=^(nil a b c), new=^(nil r) yields ^(r a b c)
                old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
            
              If oldRoot was null, it's ok, just return newRoot (even if isNil).
            
                old=null, new=r yields r
                old=null, new=^(nil r) yields ^(nil r)
            
              Return newRoot.  Throw an exception if newRoot is not a
              simple node or nil root with a single child node--it must be a root
              node.  If newRoot is ^(nil x) return x as newRoot.
            
              Be advised that it's ok for newRoot to point at oldRoot's
              children; i.e., you don't have to copy the list.  We are
              constructing these nodes so we should have this control for
              efficiency.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.RulePostProcessing(System.Object)">
            <summary>Transform ^(nil x) to x and nil to null</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.CreateToken(System.Int32,System.String)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.CreateToken(Antlr.Runtime.IToken)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              This is a variant of createToken where the new token is derived from
              an actual real input token.  Typically this is for converting '{'
              tokens to BLOCK etc...  You'll see
            
                r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
            
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.DupNode(System.Object)">
            <summary>
              Duplicate a node.  This is part of the factory;
              override if you want another kind of node to be built.
              </summary>
            
              <remarks>
              I could use reflection to prevent having to override this
              but reflection is slow.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.SetTokenBoundaries(System.Object,Antlr.Runtime.IToken,Antlr.Runtime.IToken)">
            <summary>
            Track start/stop token for subtree root created for a rule.
            Only works with Tree nodes.  For rules that match nothing,
            seems like this will yield start=i and stop=i-1 in a nil node.
            Might be useful info so I'll not force to be i..i.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.BufferedTreeNodeStream">
            <summary>A buffered stream of tree nodes.  Nodes can be from a tree of ANY kind.</summary>
            
              This node stream sucks all nodes out of the tree specified in
              the constructor during construction and makes pointers into
              the tree using an array of Object pointers. The stream necessarily
              includes pointers to DOWN and UP and EOF nodes.
            
              This stream knows how to mark/release for backtracking.
            
              This stream is most suitable for tree interpreters that need to
              jump around a lot or for tree parsers requiring speed (at cost of memory).
              There is some duplicated functionality here with UnBufferedTreeNodeStream
              but just in bookkeeping, not tree walking etc...
            
              TARGET DEVELOPERS:
            
              This is the old CommonTreeNodeStream that buffered up entire node stream.
              No need to implement really as new CommonTreeNodeStream is much better
              and covers what we need.
            
              @see CommonTreeNodeStream
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.nodes">
            <summary>The complete mapping from stream index to tree node.
              This buffer includes pointers to DOWN, UP, and EOF nodes.
              It is built upon ctor invocation.  The elements are type
              Object as we don't what the trees look like.</summary>
            
              Load upon first need of the buffer so we can set token types
              of interest for reverseIndexing.  Slows us down a wee bit to
              do all of the if p==-1 testing everywhere though.
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.root">
            <summary>Pull nodes from which tree?</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.tokens">
            <summary>IF this tree (root) was created from a token stream, track it.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.adaptor">
            <summary>What tree adaptor was used to build these trees</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.uniqueNavigationNodes">
            <summary>Reuse same DOWN, UP navigation nodes unless this is true</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.p">
            <summary>The index into the nodes list of the current node (next node
            to consume).  If -1, nodes array not filled yet.</summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.calls">
            <summary>Stack of indexes used for push/pop calls</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.FillBuffer">
            Walk tree with depth-first-search and fill nodes buffer.
            Don't do DOWN, UP nodes if its a list (t is isNil).
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.GetNodeIndex(System.Object)">
            What is the stream index for node? 0..n-1
            Return -1 if node not found.
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.AddNavigationNode(System.Int32)">
            As we flatten the tree, we use UP, DOWN nodes to represent
            the tree structure.  When debugging we need unique nodes
            so instantiate new ones when uniqueNavigationNodes is true.
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.LB(System.Int32)">
            <summary>Look backwards k nodes</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.Push(System.Int32)">
            <summary>
            Make stream jump to a new location, saving old location.
            Switch back with pop().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.Pop">
            <summary>
            Seek back to previous index saved during last push() call.
            Return top of stack (return index).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.ToTokenTypeString">
            <summary>Used for testing, just return the token type stream</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.ToTokenString(System.Int32,System.Int32)">
            <summary>Debugging</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.CommonErrorNode">
            <summary>A node representing erroneous token range in token stream</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.CommonTree">
            <summary>
            A tree node that is wrapper for a Token object.  After 3.0 release
            while building tree rewrite stuff, it became clear that computing
            parent and child index is very difficult and cumbersome.  Better to
            spend the space in every tree node.  If you don't want these extra
            fields, it's easy to cut them out in your own BaseTree subclass.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree._token">
            <summary>A single token is the payload</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree.startIndex">
            <summary>
            What token indexes bracket all tokens associated with this node
            and below?
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree.parent">
            <summary>Who is the parent node of this node; if null, implies node is root</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree.childIndex">
            <summary>What index is this node in the child list? Range: 0..n-1</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTree.SetUnknownTokenBoundaries">
            <summary>
            For every node in this subtree, make sure it's start/stop token's
            are set.  Walk depth first, visit bottom up.  Only updates nodes
            with at least one token index &lt; 0.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.CommonTreeAdaptor">
            <summary>
              A TreeAdaptor that works with any Tree implementation.  It provides
              really just factory methods; all the work is done by BaseTreeAdaptor.
              If you would like to have different tokens created than ClassicToken
              objects, you need to override this and then set the parser tree adaptor to
              use your subclass.
              </summary>
            
              <remarks>
              To get your parser to build nodes of a different type, override
              create(Token), errorNode(), and to be safe, YourTreeClass.dupNode().
              dupNode is called to duplicate nodes during rewrite operations.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeAdaptor.CreateToken(System.Int32,System.String)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeAdaptor.CreateToken(Antlr.Runtime.IToken)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              This is a variant of createToken where the new token is derived from
              an actual real input token.  Typically this is for converting '{'
              tokens to BLOCK etc...  You'll see
            
                r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
            
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeAdaptor.GetToken(System.Object)">
            <summary>
            What is the Token associated with this node?  If
            you are not using CommonTree, then you must
            override this in your own adaptor.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._root">
            <summary>Pull nodes from which tree?</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream.tokens">
            <summary>If this tree (root) was created from a token stream, track it.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._adaptor">
            <summary>What tree adaptor was used to build these trees</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._it">
            The tree iterator we are using 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._calls">
            <summary>Stack of indexes used for push/pop calls</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._hasNilRoot">
            <summary>Tree (nil A B C) trees like flat A B C streams</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._level">
            <summary>Tracks tree depth.  Level=0 means we're at root node level.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._previousLocationElement">
             Tracks the last node before the start of {@link #data} which contains
             position information to provide information for error reporting. This is
             tracked in addition to {@link #prevElement} which may or may not contain
             position information.
            
             @see #hasPositionInformation
             @see RecognitionException#extractInformationFromTreeNodeStream
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeNodeStream.Push(System.Int32)">
            Make stream jump to a new location, saving old location.
            Switch back with pop().
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeNodeStream.Pop">
            Seek back to previous index saved during last push() call.
            Return top of stack (return index).
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeNodeStream.GetKnownPositionElement(System.Boolean)">
             Returns an element containing position information. If {@code allowApproximateLocation} is {@code false}, then
             this method will return the {@code LT(1)} element if it contains position information, and otherwise return {@code null}.
             If {@code allowApproximateLocation} is {@code true}, then this method will return the last known element containing position information.
            
             @see #hasPositionInformation
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeNodeStream.ToTokenTypeString">
            <summary>For debugging; destructive: moves tree iterator to end.</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.DotTreeGenerator">
            A utility class to generate DOT diagrams (graphviz) from
              arbitrary trees.  You can pass in your own templates and
              can pass in any kind of tree or use Tree interface method.
              I wanted this separator so that you don't have to include
              ST just to use the org.antlr.runtime.tree.* package.
              This is a set of non-static methods so you can subclass
              to override.  For example, here is an invocation:
            
                  CharStream input = new ANTLRInputStream(System.in);
                  TLexer lex = new TLexer(input);
                  CommonTokenStream tokens = new CommonTokenStream(lex);
                  TParser parser = new TParser(tokens);
                  TParser.e_return r = parser.e();
                  Tree t = (Tree)r.tree;
                  System.out.println(t.toStringTree());
                  DOTTreeGenerator gen = new DOTTreeGenerator();
                  StringTemplate st = gen.toDOT(t);
                  System.out.println(st);
        </member>
        <member name="F:Antlr.Runtime.Tree.DotTreeGenerator.nodeToNumberMap">
            Track node to number mapping so we can get proper node name back 
        </member>
        <member name="F:Antlr.Runtime.Tree.DotTreeGenerator.nodeNumber">
            Track node number so we can get unique node names 
        </member>
        <member name="M:Antlr.Runtime.Tree.DotTreeGenerator.ToDot(System.Object,Antlr.Runtime.Tree.ITreeAdaptor)">
            Generate DOT (graphviz) for a whole tree not just a node.
              For example, 3+4*5 should generate:
            
             digraph {
               node [shape=plaintext, fixedsize=true, fontsize=11, fontname="Courier",
                     width=.4, height=.2];
               edge [arrowsize=.7]
               "+"->3
               "+"->"*"
               "*"->4
               "*"->5
             }
            
             Takes a Tree interface object.
        </member>
        <member name="T:Antlr.Runtime.Tree.IPositionTrackingStream">
            
             @author Sam Harwell
        </member>
        <member name="M:Antlr.Runtime.Tree.IPositionTrackingStream.GetKnownPositionElement(System.Boolean)">
             Returns an element containing concrete information about the current
             position in the stream.
            
             @param allowApproximateLocation if {@code false}, this method returns
             {@code null} if an element containing exact information about the current
             position is not available
        </member>
        <member name="M:Antlr.Runtime.Tree.IPositionTrackingStream.HasPositionInformation(System.Object)">
             Determines if the specified {@code element} contains concrete position
             information.
            
             @param element the element to check
             @return {@code true} if {@code element} contains concrete position
             information, otherwise {@code false}
        </member>
        <member name="T:Antlr.Runtime.Tree.ITree">
            <summary>
              What does a tree look like?  ANTLR has a number of support classes
              such as CommonTreeNodeStream that work on these kinds of trees.  You
              don't have to make your trees implement this interface, but if you do,
              you'll be able to use more support code.
              </summary>
            
              <remarks>
              NOTE: When constructing trees, ANTLR can build any kind of tree; it can
              even use Token objects as trees if you add a child list to your tokens.
            
              This is a tree node without any payload; just navigation and factory stuff.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.HasAncestor(System.Int32)">
            <summary>Is there is a node above with token type ttype?</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.GetAncestor(System.Int32)">
            <summary>Walk upwards and get first ancestor with this token type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.GetAncestors">
            <summary>
            Return a list of all ancestors of this node.  The first node of
            list is the root and the last is the parent of this node.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.ChildIndex">
            <summary>This node is what child index? 0..n-1</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.FreshenParentAndChildIndexes">
            <summary>Set the parent and child index values for all children</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.AddChild(Antlr.Runtime.Tree.ITree)">
            <summary>
            Add t as a child to this node.  If t is null, do nothing.  If t
            is nil, add all children of t to this' children.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.SetChild(System.Int32,Antlr.Runtime.Tree.ITree)">
            <summary>Set ith child (0..n-1) to t; t must be non-null and non-nil node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.ReplaceChildren(System.Int32,System.Int32,System.Object)">
            <summary>
            Delete children from start to stop and replace with t even if t is
            a list (nil-root tree).  num of children can increase or decrease.
            For huge child lists, inserting children can force walking rest of
            children to set their childindex; could be slow.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.IsNil">
            <summary>
            Indicates the node is a nil node but may still have children, meaning
            the tree is a flat list.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.TokenStartIndex">
            <summary>
            What is the smallest token index (indexing from 0) for this node
            and its children?
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.TokenStopIndex">
            <summary>
            What is the largest token index (indexing from 0) for this node
            and its children?
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.Type">
            <summary>Return a token type; needed for tree parsing</summary> 
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.Line">
            <summary>In case we don't have a token payload, what is the line for errors?</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.ITreeAdaptor">
            <summary>
              How to create and navigate trees.  Rather than have a separate factory
              and adaptor, I've merged them.  Makes sense to encapsulate.
              </summary>
            
              <remarks>
              This takes the place of the tree construction code generated in the
              generated code in 2.x and the ASTFactory.
            
              I do not need to know the type of a tree at all so they are all
              generic Objects.  This may increase the amount of typecasting needed. :(
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(Antlr.Runtime.IToken)">
            <summary>
              Create a tree node from Token object; for CommonTree type trees,
              then the token just becomes the payload.  This is the most
              common create call.
              </summary>
            
              <remarks>
              Override if you want another kind of node to be built.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(System.Int32,Antlr.Runtime.IToken)">
            <summary>
              Create a new node derived from a token, with a new token type.
              This is invoked from an imaginary node ref on right side of a
              rewrite rule as IMAG[$tokenLabel].
              </summary>
            
              <remarks>
              This should invoke createToken(Token).
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(System.Int32,Antlr.Runtime.IToken,System.String)">
            <summary>
              Same as create(tokenType,fromToken) except set the text too.
              This is invoked from an imaginary node ref on right side of a
              rewrite rule as IMAG[$tokenLabel, "IMAG"].
              </summary>
            
              <remarks>
              This should invoke createToken(Token).
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(Antlr.Runtime.IToken,System.String)">
            <summary>
              Same as create(fromToken) except set the text too.
              This is invoked when the <c>text</c> terminal option is set, as in
              IMAG&lt;text='IMAG'&gt;.
              </summary>
            
              <remarks>
              This should invoke createToken(Token).
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(System.Int32,System.String)">
            <summary>
              Create a new node derived from a token, with a new token type.
              This is invoked from an imaginary node ref on right side of a
              rewrite rule as IMAG["IMAG"].
              </summary>
            
              <remarks>
              This should invoke createToken(int,String).
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.DupNode(System.Object)">
            <summary>Duplicate a single tree node.</summary>
            <remarks>Override if you want another kind of node to be built.</remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.DupTree(System.Object)">
            <summary>Duplicate tree recursively, using dupNode() for each node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Nil">
            <summary>
            Return a nil node (an empty but non-null node) that can hold
            a list of element as the children.  If you want a flat tree (a list)
            use "t=adaptor.nil(); t.addChild(x); t.addChild(y);"
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.ErrorNode(Antlr.Runtime.ITokenStream,Antlr.Runtime.IToken,Antlr.Runtime.IToken,Antlr.Runtime.RecognitionException)">
            <summary>
              Return a tree node representing an error.  This node records the
              tokens consumed during error recovery.  The start token indicates the
              input symbol at which the error was detected.  The stop token indicates
              the last symbol consumed during recovery.
              </summary>
            
              <remarks>
              You must specify the input stream so that the erroneous text can
              be packaged up in the error node.  The exception could be useful
              to some applications; default implementation stores ptr to it in
              the CommonErrorNode.
            
              This only makes sense during token parsing, not tree parsing.
              Tree parsing should happen only when parsing and tree construction
              succeed.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.IsNil(System.Object)">
            <summary>Is tree considered a nil node used to make lists of child nodes?</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.AddChild(System.Object,System.Object)">
            <summary>
            Add a child to the tree t.  If child is a flat tree (a list), make all
            in list children of t.  Warning: if t has no children, but child does
            and child isNil then you can decide it is ok to move children to t via
            t.children = child.children; i.e., without copying the array.  Just
            make sure that this is consistent with have the user will build
            ASTs.  Do nothing if t or child is null.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.BecomeRoot(System.Object,System.Object)">
            <summary>
              If oldRoot is a nil root, just copy or move the children to newRoot.
              If not a nil root, make oldRoot a child of newRoot.
              </summary>
            
              <remarks>
                old=^(nil a b c), new=r yields ^(r a b c)
                old=^(a b c), new=r yields ^(r ^(a b c))
            
              If newRoot is a nil-rooted single child tree, use the single
              child as the new root node.
            
                old=^(nil a b c), new=^(nil r) yields ^(r a b c)
                old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
            
              If oldRoot was null, it's ok, just return newRoot (even if isNil).
            
                old=null, new=r yields r
                old=null, new=^(nil r) yields ^(nil r)
            
              Return newRoot.  Throw an exception if newRoot is not a
              simple node or nil root with a single child node--it must be a root
              node.  If newRoot is ^(nil x) return x as newRoot.
            
              Be advised that it's ok for newRoot to point at oldRoot's
              children; i.e., you don't have to copy the list.  We are
              constructing these nodes so we should have this control for
              efficiency.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.RulePostProcessing(System.Object)">
            <summary>
              Given the root of the subtree created for this rule, post process
              it to do any simplifications or whatever you want.  A required
              behavior is to convert ^(nil singleSubtree) to singleSubtree
              as the setting of start/stop indexes relies on a single non-nil root
              for non-flat trees.
              </summary>
            
              <remarks>
              Flat trees such as for lists like "idlist : ID+ ;" are left alone
              unless there is only one ID.  For a list, the start/stop indexes
              are set in the nil node.
            
              This method is executed after all rule tree construction and right
              before setTokenBoundaries().
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetUniqueID(System.Object)">
            <summary>For identifying trees.</summary>
            
              <remarks>
              How to identify nodes so we can say "add node to a prior node"?
              Even becomeRoot is an issue.  Use System.identityHashCode(node)
              usually.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.BecomeRoot(Antlr.Runtime.IToken,System.Object)">
            <summary>
              Create a node for newRoot make it the root of oldRoot.
              If oldRoot is a nil root, just copy or move the children to newRoot.
              If not a nil root, make oldRoot a child of newRoot.
              </summary>
            
              <returns>
              Return node created for newRoot.
              </returns>
            
              <remarks>
              Be advised: when debugging ASTs, the DebugTreeAdaptor manually
              calls create(Token child) and then plain becomeRoot(node, node)
              because it needs to trap calls to create, but it can't since it delegates
              to not inherits from the TreeAdaptor.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetType(System.Object)">
            <summary>For tree parsing, I need to know the token type of a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetType(System.Object,System.Int32)">
            <summary>Node constructors can set the type of a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetText(System.Object,System.String)">
            <summary>Node constructors can set the text of a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetToken(System.Object)">
            <summary>
            Return the token object from which this node was created.
            Currently used only for printing an error message.
            The error display routine in BaseRecognizer needs to
            display where the input the error occurred. If your
            tree of limitation does not store information that can
            lead you to the token, you can create a token filled with
            the appropriate information and pass that back.  See
            BaseRecognizer.getErrorMessage().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetTokenBoundaries(System.Object,Antlr.Runtime.IToken,Antlr.Runtime.IToken)">
            <summary>
            Where are the bounds in the input token stream for this node and
            all children?  Each rule that creates AST nodes will call this
            method right before returning.  Flat trees (i.e., lists) will
            still usually have a nil root node just to hold the children list.
            That node would contain the start/stop indexes then.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetTokenStartIndex(System.Object)">
            <summary>Get the token start index for this subtree; return -1 if no such index</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetTokenStopIndex(System.Object)">
            <summary>Get the token stop index for this subtree; return -1 if no such index</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetChild(System.Object,System.Int32)">
            <summary>Get a child 0..n-1 node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetChild(System.Object,System.Int32,System.Object)">
            <summary>Set ith child (0..n-1) to t; t must be non-null and non-nil node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.DeleteChild(System.Object,System.Int32)">
            <summary>Remove ith child and shift children down from right.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetChildCount(System.Object)">
            <summary>How many children?  If 0, then this is a leaf node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetParent(System.Object)">
            <summary>
            Who is the parent node of this node; if null, implies node is root.
            If your node type doesn't handle this, it's ok but the tree rewrites
            in tree parsers need this functionality.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetChildIndex(System.Object)">
            <summary>
            What index is this node in the child list? Range: 0..n-1
            If your node type doesn't handle this, it's ok but the tree rewrites
            in tree parsers need this functionality.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.ReplaceChildren(System.Object,System.Int32,System.Int32,System.Object)">
            <summary>
              Replace from start to stop child index of parent with t, which might
              be a list.  Number of children may be different after this call.
              </summary>
            
              <remarks>
              If parent is null, don't do anything; must be at root of overall tree.
              Can't replace whatever points to the parent externally.  Do nothing.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.Tree.ITreeNodeStream">
            <summary>A stream of tree nodes, accessing nodes from a tree of some kind</summary> 
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.Item(System.Int32)">
            <summary>
            Get a tree node at an absolute index i; 0..n-1.
            If you don't want to buffer up nodes, then this method makes no
            sense for you.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeNodeStream.LT(System.Int32)">
            <summary>
             Get tree node at current input pointer + <paramref name="k"/> ahead where
             <paramref name="k"/>==1 is next node. <paramref name="k"/>&lt;0 indicates nodes in the past. So
             {@code LT(-1)} is previous node, but implementations are not required to
             provide results for <paramref name="k"/> &lt; -1. {@code LT(0)} is undefined. For
             <paramref name="k"/>&lt;=n, return <see langword="null"/>. Return <see langword="null"/> for {@code LT(0)}
             and any index that results in an absolute address that is negative.
              </summary>
            
              <remarks>
             This is analogous to <see cref="M:Antlr.Runtime.ITokenStream.LT(System.Int32)"/>, but this returns a tree node
             instead of a <see cref="T:Antlr.Runtime.IToken"/>. Makes code generation identical for both
             parser and tree grammars.
              </remarks>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.TreeSource">
            <summary>
            Where is this stream pulling nodes from?  This is not the name, but
            the object that provides node objects.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.TokenStream">
            <summary>
            If the tree associated with this stream was created from a
            {@link TokenStream}, you can specify it here. Used to do rule
            {@code $text} attribute in tree parser. Optional unless you use tree
            parser rule {@code $text} attribute or {@code output=template} and
            {@code rewrite=true} options.
             </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.TreeAdaptor">
            <summary>
            What adaptor can tell me how to interpret/navigate nodes and
            trees.  E.g., get text of a node.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.UniqueNavigationNodes">
            <summary>
            As we flatten the tree, we use {@link Token#UP}, {@link Token#DOWN} nodes
            to represent the tree structure. When debugging we need unique nodes so
            we have to instantiate new ones. When doing normal tree parsing, it's
            slow and a waste of memory to create unique navigation nodes. Default
            should be {@code false}.
             </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeNodeStream.ToString(System.Object,System.Object)">
            <summary>
            Return the text of all nodes from {@code start} to {@code stop},
            inclusive. If the stream does not buffer all the nodes then it can still
            walk recursively from start until stop. You can always return
            {@code null} or {@code ""} too, but users should not access
            {@code $ruleLabel.text} in an action of course in that case.
             </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeNodeStream.ReplaceChildren(System.Object,System.Int32,System.Int32,System.Object)">
            <summary>
             Replace children of {@code parent} from index {@code startChildIndex} to
             {@code stopChildIndex} with {@code t}, which might be a list. Number of
             children may be different after this call. The stream is notified because
             it is walking the tree and might need to know you are monkeying with the
             underlying tree. Also, it might be able to modify the node stream to
             avoid restreaming for future phases.
              </summary>
            
              <remarks>
             If {@code parent} is {@code null}, don't do anything; must be at root of
             overall tree. Can't replace whatever points to the parent externally. Do
             nothing.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.Tree.ITreeVisitorAction">
            <summary>
            How to execute code for node t when a visitor visits node t.  Execute
            pre() before visiting children and execute post() after visiting children.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeVisitorAction.Pre(System.Object)">
            <summary>
            Execute an action before visiting children of t.  Return t or
            a rewritten t.  It is up to the visitor to decide what to do
            with the return value.  Children of returned value will be
            visited if using TreeVisitor.visit().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeVisitorAction.Post(System.Object)">
            <summary>
            Execute an action after visiting children of t.  Return t or
            a rewritten t.  It is up to the visitor to decide what to do
            with the return value.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.ParseTree">
            <summary>
            A record of the rules used to match a token sequence.  The tokens
            end up as the leaves of this tree and rule nodes are the interior nodes.
            This really adds no functionality, it is just an alias for CommonTree
            that is more meaningful (specific) and holds a String to display for a node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ParseTree.ToStringWithHiddenTokens">
            <summary>
            Emit a token and all hidden nodes before.  EOF node holds all
            hidden tokens after last real token.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ParseTree.ToInputString">
            <summary>
            Print out the leaves of this tree, which means printing original
            input back out.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteCardinalityException">
            <summary>
            Base class for all exceptions thrown during AST rewrite construction.
            This signifies a case where the cardinality of two or more elements
            in a subrule are different: (ID INT)+ where |ID|!=|INT|
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteEarlyExitException">
            <summary>No elements within a (...)+ in a rewrite rule</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteEmptyStreamException">
            <summary>Ref to ID or expr but no tokens in ID stream or subtrees in expr stream</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteRuleElementStream">
            <summary>
              A generic list of elements tracked in an alternative to be used in
              a -> rewrite rule.  We need to subclass to fill in the next() method,
              which returns either an AST node wrapped around a token payload or
              an existing subtree.
              </summary>
            
              <remarks>
              Once you start next()ing, do not try to add more elements.  It will
              break the cursor tracking I believe.
            
              TODO: add mechanism to detect/puke on modification after reading from stream
              </remarks>
            
              <see cref="T:Antlr.Runtime.Tree.RewriteRuleSubtreeStream"/>
              <see cref="T:Antlr.Runtime.Tree.RewriteRuleTokenStream"/>
        </member>
        <member name="F:Antlr.Runtime.Tree.RewriteRuleElementStream.cursor">
            <summary>
            Cursor 0..n-1.  If singleElement!=null, cursor is 0 until you next(),
            which bumps it to 1 meaning no more elements.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.RewriteRuleElementStream.singleElement">
            <summary>Track single elements w/o creating a list.  Upon 2nd add, alloc list</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.RewriteRuleElementStream.elements">
            <summary>The list of tokens or subtrees we are tracking</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.RewriteRuleElementStream.dirty">
            <summary>Once a node / subtree has been used in a stream, it must be dup'd
            from then on.  Streams are reset after subrules so that the streams
            can be reused in future subrules.  So, reset must set a dirty bit.
            If dirty, then next() always returns a dup.</summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.RewriteRuleElementStream.elementDescription">
            <summary>The element or stream description; usually has name of the token or
            rule reference that this list tracks.  Can include rulename too, but
            the exception would track that info.</summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>Create a stream with one element</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.IList)">
            <summary>Create a stream, but feed off an existing list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.Reset">
            <summary>
            Reset the condition of this stream so that it appears we have
            not consumed any of its elements.  Elements themselves are untouched.
            Once we reset the stream, any future use will need duplicates.  Set
            the dirty bit.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.NextTree">
            <summary>
            Return the next element in the stream.  If out of elements, throw
            an exception unless size()==1.  If size is 1, then return elements[0].
            Return a duplicate node/subtree if stream is out of elements and
            size==1.  If we've already used the element, dup (dirty bit set).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.NextCore">
            <summary>
            Do the work of getting the next element, making sure that it's
            a tree node or subtree.  Deal with the optimization of single-
            element list versus list of size > 1.  Throw an exception
            if the stream is empty or we're out of elements and size>1.
            protected so you can override in a subclass if necessary.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.Dup(System.Object)">
            <summary>
             When constructing trees, sometimes we need to dup a token or AST
            	subtree.  Dup'ing a token means just creating another AST node
             around it.  For trees, you must call the adaptor.dupTree() unless
             the element is for a tree root; then it must be a node dup.
             </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.ToTree(System.Object)">
            <summary>
            Ensure stream emits trees; tokens must be converted to AST nodes.
            AST nodes can be passed through unmolested.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteRuleNodeStream">
            <summary>
            Queues up nodes matched on left side of -> in a tree parser. This is
            the analog of RewriteRuleTokenStream for normal parsers.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleNodeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>Create a stream with one element</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleNodeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.IList)">
            <summary>Create a stream, but feed off an existing list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleSubtreeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>Create a stream with one element</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleSubtreeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.IList)">
            <summary>Create a stream, but feed off an existing list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleSubtreeStream.NextNode">
            <summary>
              Treat next element as a single node even if it's a subtree.
              This is used instead of next() when the result has to be a
              tree root node.  Also prevents us from duplicating recently-added
              children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration
              must dup the type node, but ID has been added.
              </summary>
            
              <remarks>
              Referencing a rule result twice is ok; dup entire tree as
              we can't be adding trees as root; e.g., expr expr.
            
              Hideous code duplication here with super.next().  Can't think of
              a proper way to refactor.  This needs to always call dup node
              and super.next() doesn't know which to call: dup node or dup tree.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>Create a stream with one element</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.IList)">
            <summary>Create a stream, but feed off an existing list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.NextNode">
            <summary>Get next token from stream and make a node for it</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.ToTree(System.Object)">
            <summary>
            Don't convert to a tree unless they explicitly call nextTree.
            This way we can do hetero tree nodes in rewrite.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeIterator">
            Return a node stream from a doubly-linked tree whose nodes
              know what child index they are.  No remove() is supported.
            
              Emit navigation nodes (DOWN, UP, and EOF) to let show tree structure.
        </member>
        <member name="F:Antlr.Runtime.Tree.TreeIterator.nodes">
            If we emit UP/DOWN nodes, we need to spit out multiple nodes per
            next() call.
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeParser">
            <summary>
            A parser for a stream of tree nodes.  "tree grammars" result in a subclass
            of this.  All the error reporting and recovery is shared with Parser via
            the BaseRecognizer superclass.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.SetTreeNodeStream(Antlr.Runtime.Tree.ITreeNodeStream)">
            <summary>Set the input stream</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.MatchAny(Antlr.Runtime.IIntStream)">
            <summary>
            Match '.' in tree parser has special meaning.  Skip node or
            entire tree if node has children.  If children, scan until
            corresponding UP node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.RecoverFromMismatchedToken(Antlr.Runtime.IIntStream,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
            We have DOWN/UP nodes in the stream that have no line info; override.
            plus we want to alter the exception type.  Don't try to recover
            from tree parser errors inline...
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.GetErrorHeader(Antlr.Runtime.RecognitionException)">
            <summary>
            Prefix error message with the grammar name because message is
            always intended for the programmer because the parser built
            the input tree not the user.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.GetErrorMessage(Antlr.Runtime.RecognitionException,System.String[])">
            <summary>
            Tree parsers parse nodes they usually have a token object as
            payload. Set the exception token and do the default behavior.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.pattern">
            <summary>The tree pattern to lex like "(A B C)"</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.p">
            <summary>Index into input string</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.c">
            <summary>Current char</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.n">
            <summary>How long is the pattern in char?</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.sval">
            <summary>Set when token type is ID or ARG (name mimics Java's StreamTokenizer)</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeRewriter.ReportTransformation(System.Object,System.Object)">
            Override this if you need transformation tracing to go somewhere
            other than stdout or if you're not using ITree-derived trees.
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeRuleReturnScope`1">
            <summary>
            This is identical to the ParserRuleReturnScope except that
            the start property is a tree nodes not Token object
            when you are parsing trees.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.TreeRuleReturnScope`1.Start">
            <summary>Gets the first node or root node of tree matched for this rule.</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeVisitor">
            <summary>Do a depth first walk of a tree, applying pre() and post() actions as we go.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeVisitor.Visit(System.Object,Antlr.Runtime.Tree.ITreeVisitorAction)">
            <summary>
            Visit every node in tree t and trigger an action for each node
            before/after having visited all of its children.  Bottom up walk.
            Execute both actions even if t has no children.  Ignore return
            results from transforming children since they will have altered
            the child list of this node (their parent).  Return result of
            applying post action to this node.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeWizard">
            <summary>
              Build and navigate trees with this object.  Must know about the names
              of tokens so you have to pass in a map or array of token names (from which
              this class can build the map).  I.e., Token DECL means nothing unless the
              class can translate it to a token type.
              </summary>
            
              <remarks>
              In order to create nodes and navigate, this class needs a TreeAdaptor.
            
              This class can build a token type -> node index for repeated use or for
              iterating over the various nodes with a particular type.
            
              This class works in conjunction with the TreeAdaptor rather than moving
              all this functionality into the adaptor.  An adaptor helps build and
              navigate trees using methods.  This class helps you do it with string
              patterns like "(A B C)".  You can create a tree from that pattern or
              match subtrees against it.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeWizard.TreePattern">
            <summary>
            When using %label:TOKENNAME in a tree for parse(), we must
            track the label.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeWizard.TreePatternTreeAdaptor">
            <summary>This adaptor creates TreePattern objects for use during scan()</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.ComputeTokenTypes(System.String[])">
            <summary>
            Compute a Map&lt;String, Integer&gt; that is an inverted index of
            tokenNames (which maps int token types to names).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.GetTokenType(System.String)">
            <summary>Using the map of token names to token types, return the type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Index(System.Object)">
            <summary>
              Walk the entire tree and make a node name to nodes mapping.
              For now, use recursion but later nonrecursive version may be
              more efficient.  Returns Map&lt;Integer, List&gt; where the List is
              of your AST node type.  The Integer is the token type of the node.
              </summary>
            
              <remarks>
              TODO: save this index so that find and visit are faster
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.IndexCore(System.Object,System.Collections.Generic.IDictionary{System.Int32,System.Collections.IList})">
            <summary>Do the work for index</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Find(System.Object,System.Int32)">
            <summary>Return a List of tree nodes with token type ttype</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Find(System.Object,System.String)">
            <summary>Return a List of subtrees matching pattern.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Visit(System.Object,System.Int32,Antlr.Runtime.Tree.TreeWizard.IContextVisitor)">
            <summary>
            Visit every ttype node in t, invoking the visitor.  This is a quicker
            version of the general visit(t, pattern) method.  The labels arg
            of the visitor action method is never set (it's null) since using
            a token type rather than a pattern doesn't let us set a label.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.VisitCore(System.Object,System.Object,System.Int32,System.Int32,Antlr.Runtime.Tree.TreeWizard.IContextVisitor)">
            <summary>Do the recursive work for visit</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Visit(System.Object,System.String,Antlr.Runtime.Tree.TreeWizard.IContextVisitor)">
            <summary>
            For all subtrees that match the pattern, execute the visit action.
            The implementation uses the root node of the pattern in combination
            with visit(t, ttype, visitor) so nil-rooted patterns are not allowed.
            Patterns with wildcard roots are also not allowed.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Parse(System.Object,System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
              Given a pattern like (ASSIGN %lhs:ID %rhs:.) with optional labels
              on the various nodes and '.' (dot) as the node/subtree wildcard,
              return true if the pattern matches and fill the labels Map with
              the labels pointing at the appropriate nodes.  Return false if
              the pattern is malformed or the tree does not match.
              </summary>
            
              <remarks>
              If a node specifies a text arg in pattern, then that must match
              for that node in t.
            
              TODO: what's a better way to indicate bad pattern? Exceptions are a hassle 
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.ParseCore(System.Object,Antlr.Runtime.Tree.TreeWizard.TreePattern,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Do the work for parse. Check to see if the t2 pattern fits the
            structure and token types in t1.  Check text if the pattern has
            text arguments on nodes.  Fill labels map with pointers to nodes
            in tree matched against nodes in pattern with labels.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Create(System.String)">
            <summary>
              Create a tree or node from the indicated tree pattern that closely
              follows ANTLR tree grammar tree element syntax:
            
                  (root child1 ... child2).
              </summary>
            
              <remarks>
              You can also just pass in a node: ID
             
              Any node can have a text argument: ID[foo]
              (notice there are no quotes around foo--it's clear it's a string).
            
              nil is a special name meaning "give me a nil node".  Useful for
              making lists: (nil A B C) is a list of A B C.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Equals(System.Object,System.Object,Antlr.Runtime.Tree.ITreeAdaptor)">
            <summary>
              Compare t1 and t2; return true if token types/text, structure match exactly.
              The trees are examined in their entirety so that (A B) does not match
              (A B C) nor (A (B C)). 
              </summary>
            
              <remarks>
              TODO: allow them to pass in a comparator
              TODO: have a version that is nonstatic so it can use instance adaptor
            
              I cannot rely on the tree node's equals() implementation as I make
              no constraints at all on the node types nor interface etc... 
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Equals(System.Object,System.Object)">
            <summary>
            Compare type, structure, and text of two trees, assuming adaptor in
            this instance of a TreeWizard.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.UnbufferedTokenStream">
            A token stream that pulls tokens from the code source on-demand and
              without tracking a complete buffer of the tokens. This stream buffers
              the minimum number of tokens possible.  It's the same as
              OnDemandTokenStream except that OnDemandTokenStream buffers all tokens.
            
              You can't use this stream if you pass whitespace or other off-channel
              tokens to the parser. The stream can't ignore off-channel tokens.
             
              You can only look backwards 1 token: LT(-1).
            
              Use this when you need to read from a socket or other infinite stream.
            
              @see BufferedTokenStream
              @see CommonTokenStream
        </member>
        <member name="F:Antlr.Runtime.UnbufferedTokenStream.channel">
            Skip tokens on any channel but this one; this is how we skip whitespace... 
        </member>
        <member name="T:Antlr.Runtime.UnwantedTokenException">
            <summary>An extra token while parsing a TokenStream</summary> 
        </member>
    </members>
</doc>
